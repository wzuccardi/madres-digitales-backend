// Servicio para gestantes con funcionalidades completas
// Todos los datos provienen de la base de datos real, no se usan mocks
import prisma from '../config/database';
import { Prisma } from '@prisma/client';
import type {
	FiltrosGestanteDTO,
	RespuestaPaginada,
	BusquedaGeograficaDTO,
	RiesgoGestante
} from '../types/gestante.dto';

export class GestanteService {
	// M√âTODO ORIGINAL - SOLO PARA ADMINISTRADORES
	async getAllGestantes() {
		console.log('ü§∞ GestanteService: Fetching all gestantes (ADMIN ONLY)...');
		const gestantes = await prisma.gestante.findMany({
			orderBy: { created_at: 'desc' }
		});
		console.log(`ü§∞ GestanteService: Found ${gestantes.length} gestantes`);
		return gestantes;
	}

	// NUEVO M√âTODO - FILTRADO POR MADRINA (SEGURIDAD)
	async getGestantesByMadrina(madrinaId: string) {
		console.log(`ü§∞ GestanteService: Fetching gestantes for madrina ${madrinaId}...`);
		const gestantes = await prisma.gestante.findMany({
			where: {
				madrina_id: madrinaId // FILTRO CR√çTICO DE SEGURIDAD
			},
			include: {
				municipio: true,
				ipsAsignada: {
					select: {
						id: true,
						nombre: true,
						telefono: true,
					}
				}
			} as any,
			orderBy: { created_at: 'desc' }
		});
		console.log(`ü§∞ GestanteService: Found ${gestantes.length} gestantes for madrina ${madrinaId}`);
		return gestantes;
	}

	async getGestanteById(id: string) {
		return prisma.gestante.findUnique({
			where: { id },
			include: {
				municipio: true,
				madrina: {
					select: {
						id: true,
						nombre: true,
						telefono: true,
					}
				},
				ipsAsignada: {
					select: {
						id: true,
						nombre: true,
						telefono: true,
						direccion: true,
					}
				},
				medicoAsignado: {
					select: {
						id: true,
						nombre: true,
						especialidad: true,
						telefono: true,
					}
				},
				controles: {
					orderBy: { fecha_control: 'desc' },
					take: 5,
				},
				alertas: {
					where: { resuelta: false },
					orderBy: { created_at: 'desc' },
					take: 10,
				}
			}
		}) as any;
	}

	async createGestante(data: any) {
		return prisma.gestante.create({ data });
	}

	async updateGestante(id: string, data: any) {
		return prisma.gestante.update({ where: { id }, data });
	}

	async deleteGestante(id: string) {
		return prisma.gestante.delete({ where: { id } });
	}

	// M√©todo para crear gestante con validaciones completas
	async createGestanteCompleta(data: any) {
		console.log('ü§∞ GestanteService: Creating new gestante...');
		console.log('   Data received:', data);

		try {
			// Validar que el documento no exista
			const existingGestante = await prisma.gestante.findFirst({
				where: { documento: data.documento }
			});

			if (existingGestante) {
				throw new Error(`Ya existe una gestante con documento ${data.documento}`);
			}

			// Calcular FPP si se proporciona FUM
			let fechaProbableParto = data.fecha_probable_parto;
			if (data.fecha_ultima_menstruacion && !fechaProbableParto) {
				const fum = new Date(data.fecha_ultima_menstruacion);
				fechaProbableParto = new Date(fum.getTime() + (280 * 24 * 60 * 60 * 1000)); // FUM + 280 d√≠as
			}

			// Preparar coordenadas GeoJSON si se proporcionan
			let coordenadas = null;
			if (data.latitud && data.longitud) {
				coordenadas = {
					type: 'Point',
					coordinates: [data.longitud, data.latitud]
				};
			}

			// Crear la gestante
			const newGestante = await prisma.gestante.create({
				data: {
					documento: data.documento,
					tipo_documento: data.tipo_documento || 'cedula',
					nombre: data.nombre,
					fecha_nacimiento: data.fecha_nacimiento ? new Date(data.fecha_nacimiento) : new Date(),
					telefono: data.telefono || null,
					direccion: data.direccion || null,
					coordenadas: coordenadas as any,
					municipio_id: data.municipio_id || null,
					madrina_id: data.madrina_id || null,
					ips_asignada_id: data.ips_asignada_id || null,
					medico_asignado_id: data.medico_asignado_id || null,
					eps: data.eps || null,
					regimen_salud: data.regimen_salud || 'subsidiado',
					fecha_ultima_menstruacion: data.fecha_ultima_menstruacion ? new Date(data.fecha_ultima_menstruacion) : null,
					fecha_probable_parto: fechaProbableParto ? new Date(fechaProbableParto) : null,
					numero_embarazo: data.numero_embarazo || 1,
					// peso_actual: data.peso_actual || null, // Campo no existe en el esquema
					// talla: data.talla || null, // Campo no existe en el esquema
					grupo_sanguineo: data.grupo_sanguineo || null,
					factores_riesgo: data.factores_riesgo || [],
					riesgo_alto: data.riesgo_alto !== undefined ? data.riesgo_alto : (data.factores_riesgo && data.factores_riesgo.length > 0),
					activa: data.activa !== undefined ? data.activa : true,
					contacto_emergencia_nombre: data.contacto_emergencia_nombre || null,
					contacto_emergencia_telefono: data.contacto_emergencia_telefono || null,
				},
			}) as any;
			});

			console.log(`‚úÖ GestanteService: Gestante created with ID: ${newGestante.id}`);
			return newGestante;
		} catch (error) {
			console.error('‚ùå GestanteService: Error creating gestante:', error);
			throw error;
		}
	}

	// M√©todo para actualizar gestante con validaciones
	async updateGestanteCompleta(id: string, data: any) {
		console.log(`ü§∞ GestanteService: Updating gestante ${id}...`);
		console.log('   Data received:', data);

		try {
			// Verificar que la gestante existe
			const existingGestante = await prisma.gestante.findUnique({
				where: { id }
			});

			if (!existingGestante) {
				throw new Error(`No se encontr√≥ gestante con ID ${id}`);
			}

			// Si se est√° cambiando el documento, verificar que no exista otro con el mismo
			if (data.documento && data.documento !== existingGestante.documento) {
				const duplicateGestante = await prisma.gestante.findFirst({
					where: {
						documento: data.documento,
						id: { not: id }
					}
				});

				if (duplicateGestante) {
					throw new Error(`Ya existe otra gestante con documento ${data.documento}`);
				}
			}

			// Actualizar la gestante
			const updatedGestante = await prisma.gestante.update({
				where: { id },
				data: {
					documento: data.documento || existingGestante.documento,
					nombre: data.nombre || existingGestante.nombre,
					telefono: data.telefono !== undefined ? data.telefono : existingGestante.telefono,
					direccion: data.direccion !== undefined ? data.direccion : existingGestante.direccion,
					municipio_id: data.municipio_id !== undefined ? data.municipio_id : existingGestante.municipio_id,
					eps: data.eps !== undefined ? data.eps : existingGestante.eps,
					activa: data.activa !== undefined ? data.activa : existingGestante.activa,
					riesgo_alto: data.riesgo_alto !== undefined ? data.riesgo_alto : existingGestante.riesgo_alto,
					fecha_probable_parto: data.fecha_probable_parto !== undefined
						? (data.fecha_probable_parto ? new Date(data.fecha_probable_parto) : null)
						: existingGestante.fecha_probable_parto,
					fecha_nacimiento: data.fecha_nacimiento !== undefined
						? (data.fecha_nacimiento ? new Date(data.fecha_nacimiento) : new Date())
						: existingGestante.fecha_nacimiento,
				}
			});

			console.log(`‚úÖ GestanteService: Gestante ${id} updated successfully`);
			return updatedGestante;
		} catch (error) {
			console.error(`‚ùå GestanteService: Error updating gestante ${id}:`, error);
			throw error;
		}
	}

	/**
	 * B√∫squeda avanzada con filtros y paginaci√≥n
	 */
	async buscarGestantes(filtros: FiltrosGestanteDTO): Promise<RespuestaPaginada<any>> {
		console.log('üîç GestanteService: Searching gestantes with filters:', filtros);

		try {
			// Construir condiciones WHERE
			const where: Prisma.GestanteWhereInput = {};

			// B√∫squeda por texto (nombre o documento)
			if (filtros.busqueda) {
				where.OR = [
					{ nombre: { contains: filtros.busqueda, mode: 'insensitive' } },
					{ documento: { contains: filtros.busqueda } },
				];
			}

			// Filtros espec√≠ficos
			if (filtros.documento) {
				where.documento = { contains: filtros.documento };
			}

			if (filtros.nombre) {
				where.nombre = { contains: filtros.nombre, mode: 'insensitive' };
			}

			if (filtros.municipio_id) {
				where.municipio_id = filtros.municipio_id;
			}

			if (filtros.madrina_id) {
				where.madrina_id = filtros.madrina_id;
			}

			if (filtros.ips_asignada_id) {
				where.ips_asignada_id = filtros.ips_asignada_id;
			}

			if (filtros.activa !== undefined) {
				where.activa = filtros.activa;
			}

			if (filtros.riesgo_alto !== undefined) {
				where.riesgo_alto = filtros.riesgo_alto;
			}

			if (filtros.sin_madrina) {
				where.madrina_id = null;
			}

			if (filtros.sin_ips) {
				where.ips_asignada_id = null;
			}

			// Filtros de fecha
			if (filtros.fecha_parto_desde || filtros.fecha_parto_hasta) {
				where.fecha_probable_parto = {};
				if (filtros.fecha_parto_desde) {
					where.fecha_probable_parto.gte = filtros.fecha_parto_desde;
				}
				if (filtros.fecha_parto_hasta) {
					where.fecha_probable_parto.lte = filtros.fecha_parto_hasta;
				}
			}

			// Contar total de registros
			const total = await prisma.gestante.count({ where });

			// Calcular paginaci√≥n
			const page = filtros.page || 1;
			const limit = filtros.limit || 20;
			const skip = (page - 1) * limit;
			const totalPages = Math.ceil(total / limit);

			// Construir ordenamiento
			const orderBy: Prisma.GestanteOrderByWithRelationInput = {};
			const orderField = filtros.orderBy || 'created_at';
			const orderDirection = filtros.orderDirection || 'desc';
			orderBy[orderField] = orderDirection;

			// Ejecutar consulta
			const gestantes = await prisma.gestante.findMany({
				where,
				orderBy,
				skip,
				take: limit,
			});

			console.log(`‚úÖ GestanteService: Found ${gestantes.length} gestantes (${total} total)`);

			return {
				data: gestantes,
				pagination: {
					page,
					limit,
					total,
					totalPages,
					hasNextPage: page < totalPages,
					hasPrevPage: page > 1,
				}
			};
		} catch (error) {
			console.error('‚ùå GestanteService: Error searching gestantes:', error);
			throw error;
		}
	}

	/**
	 * B√∫squeda geogr√°fica de gestantes cercanas
	 */
	async buscarGestantesCercanas(params: BusquedaGeograficaDTO): Promise<any[]> {
		console.log('üìç GestanteService: Searching nearby gestantes:', params);

		try {
			// Usar PostGIS para b√∫squeda geogr√°fica
			const { latitud, longitud, radio_km, limit } = params;

			// Convertir radio de km a metros
			const radioMetros = radio_km * 1000;

			// Query SQL con PostGIS
			const gestantes = await prisma.$queryRaw<any[]>`
				SELECT
					g.*,
					ST_Distance(
						g.coordenadas::geography,
						ST_SetSRID(ST_MakePoint(${longitud}, ${latitud}), 4326)::geography
					) as distancia_metros
				FROM "Gestante" g
				WHERE g.coordenadas IS NOT NULL
				AND g.activa = true
				AND ST_DWithin(
					g.coordenadas::geography,
					ST_SetSRID(ST_MakePoint(${longitud}, ${latitud}), 4326)::geography,
					${radioMetros}
				)
				ORDER BY distancia_metros ASC
				LIMIT ${limit}
			`;

			console.log(`‚úÖ GestanteService: Found ${gestantes.length} nearby gestantes`);

			// Convertir distancia a km y agregar informaci√≥n adicional
			const gestantesConInfo = await Promise.all(
				gestantes.map(async (g) => {
					const gestanteCompleta = await prisma.gestante.findUnique({
						where: { id: g.id },
						include: {
							municipio: true,
							madrina: {
								select: {
									id: true,
									nombre: true,
									telefono: true,
								}
							}
						} as any
					});

					return {
						...gestanteCompleta,
						distancia_km: (g.distancia_metros / 1000).toFixed(2),
					};
				})
			);

			return gestantesConInfo;
		} catch (error) {
			console.error('‚ùå GestanteService: Error searching nearby gestantes:', error);
			throw error;
		}
	}

	/**
	 * Asignar madrina a gestante
	 */
	async asignarMadrina(gestanteId: string, madrinaId: string) {
		console.log(`üë©‚Äç‚öïÔ∏è GestanteService: Assigning madrina ${madrinaId} to gestante ${gestanteId}`);

		try {
			// Verificar que la gestante existe
			const gestante = await prisma.gestante.findUnique({
				where: { id: gestanteId }
			});

			if (!gestante) {
				throw new Error(`No se encontr√≥ gestante con ID ${gestanteId}`);
			}

			// Verificar que la madrina existe
			const madrina = await prisma.usuario.findUnique({
				where: { id: madrinaId }
			});

			if (!madrina) {
				throw new Error(`No se encontr√≥ madrina con ID ${madrinaId}`);
			}

			if (madrina.rol !== 'madrina') {
				throw new Error(`El usuario ${madrinaId} no es una madrina`);
			}

			// Asignar madrina
			const updatedGestante = await prisma.gestante.update({
				where: { id: gestanteId },
				data: { madrina_id: madrinaId },
				include: {
					madrina: {
						select: {
							id: true,
							nombre: true,
							telefono: true,
						}
					}
				} as any
			});

			console.log(`‚úÖ GestanteService: Madrina assigned successfully`);
			return updatedGestante;
		} catch (error) {
			console.error('‚ùå GestanteService: Error assigning madrina:', error);
			throw error;
		}
	}

	/**
	 * Calcular riesgo de gestante
	 */
	async calcularRiesgo(gestanteId: string): Promise<RiesgoGestante> {
		console.log(`‚ö†Ô∏è GestanteService: Calculating risk for gestante ${gestanteId}`);

		try {
			const gestante = await prisma.gestante.findUnique({
				where: { id: gestanteId },
				include: {
					controles: {
						orderBy: { fecha_control: 'desc' },
						take: 3,
					},
					alertas: {
						where: { resuelta: false },
						orderBy: { created_at: 'desc' },
					}
				} as any
			});

			if (!gestante) {
				throw new Error(`No se encontr√≥ gestante con ID ${gestanteId}`);
			}

			let puntuacion = 0;
			const factoresDetectados: string[] = [];
			const recomendaciones: string[] = [];

			// Factores de riesgo registrados
			if (gestante.factores_riesgo && Array.isArray(gestante.factores_riesgo)) {
				const factoresRiesgo = gestante.factores_riesgo as string[];
				puntuacion += factoresRiesgo.length * 10;
				factoresDetectados.push(...factoresRiesgo);
			}

			// Edad
			const edad = new Date().getFullYear() - new Date(gestante.fecha_nacimiento).getFullYear();
			if (edad < 18) {
				puntuacion += 15;
				factoresDetectados.push('Edad menor a 18 a√±os');
				recomendaciones.push('Control prenatal frecuente por edad materna');
			} else if (edad > 35) {
				puntuacion += 10;
				factoresDetectados.push('Edad mayor a 35 a√±os');
				recomendaciones.push('Monitoreo especial por edad materna avanzada');
			}

			// Alertas activas
			const gestanteData = gestante as any;
			if (gestanteData.alertas && Array.isArray(gestanteData.alertas) && gestanteData.alertas.length > 0) {
				const alertas = gestanteData.alertas;
				puntuacion += alertas.length * 20;
				factoresDetectados.push(`${alertas.length} alerta(s) activa(s)`);
				recomendaciones.push('Resolver alertas pendientes urgentemente');
			}

			// Controles prenatales
			if (!gestanteData.controles || !Array.isArray(gestanteData.controles) || gestanteData.controles.length === 0) {
				puntuacion += 15;
				factoresDetectados.push('Sin controles prenatales registrados');
				recomendaciones.push('Programar control prenatal inmediatamente');
			}

			// Sin madrina asignada
			if (!gestante.madrina_id) {
				puntuacion += 10;
				factoresDetectados.push('Sin madrina asignada');
				recomendaciones.push('Asignar madrina para seguimiento');
			}

			// Sin IPS asignada
			if (!gestante.ips_asignada_id) {
				puntuacion += 5;
				factoresDetectados.push('Sin IPS asignada');
				recomendaciones.push('Asignar IPS para atenci√≥n m√©dica');
			}

			// Determinar nivel de riesgo
			let nivelRiesgo: 'bajo' | 'medio' | 'alto' | 'critico';
			if (puntuacion >= 70) {
				nivelRiesgo = 'critico';
			} else if (puntuacion >= 50) {
				nivelRiesgo = 'alto';
			} else if (puntuacion >= 30) {
				nivelRiesgo = 'medio';
			} else {
				nivelRiesgo = 'bajo';
			}

			const requiereAtencionInmediata = puntuacion >= 50;

			// Actualizar riesgo_alto en la base de datos
			await prisma.gestante.update({
				where: { id: gestanteId },
				data: { riesgo_alto: nivelRiesgo === 'alto' || nivelRiesgo === 'critico' }
			});

			console.log(`‚úÖ GestanteService: Risk calculated - Level: ${nivelRiesgo}, Score: ${puntuacion}`);

			return {
				gestante_id: gestanteId,
				puntuacion_riesgo: puntuacion,
				nivel_riesgo: nivelRiesgo,
				factores_detectados: factoresDetectados,
				recomendaciones: recomendaciones,
				requiere_atencion_inmediata: requiereAtencionInmediata,
			};
		} catch (error) {
			console.error('‚ùå GestanteService: Error calculating risk:', error);
			throw error;
		}
	}
}
