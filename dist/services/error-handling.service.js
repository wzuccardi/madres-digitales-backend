"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.errorHandlingService = exports.ErrorHandlingService = void 0;
const client_1 = require("@prisma/client");
const notification_service_1 = require("./notification.service");
const log_service_1 = require("./log.service");
const logger_1 = require("../config/logger");
const prisma = new client_1.PrismaClient();
class ErrorHandlingService {
    constructor() {
        // NUEVO: Mapa para controlar errores cr√≠ticos y evitar notificaciones duplicadas
        this._erroresCriticosRecientes = new Map();
        // NUEVO: Tiempo m√≠nimo entre notificaciones del mismo error (5 minutos)
        this._tiempoMinimoNotificacion = 5 * 60 * 1000;
        // NUEVO: Contador m√°ximo de notificaciones para el mismo error en el per√≠odo
        this._maxNotificacionesPorPeriodo = 3;
        this.notificationService = new notification_service_1.NotificationService();
        this.logService = new log_service_1.LogService();
    }
    /**
     * NUEVO: Manejar errores cr√≠ticos con notificaci√≥n y logging
     */
    async manejarErrorCritico(error, contexto) {
        const startTime = Date.now();
        const errorKey = `${contexto.componente}:${contexto.accion}:${error.message}`;
        try {
            console.error(`üî¥ ErrorHandlingService: Error cr√≠tico en ${contexto.componente}.${contexto.accion}:`, error);
            // 1. Verificar si ya se notific√≥ este error recientemente
            const errorReciente = this._erroresCriticosRecientes.get(errorKey);
            const ahora = new Date();
            if (errorReciente) {
                const tiempoTranscurrido = ahora.getTime() - errorReciente.timestamp.getTime();
                // Si el error ocurri√≥ hace menos del tiempo m√≠nimo, incrementar contador
                if (tiempoTranscurrido < this._tiempoMinimoNotificacion) {
                    errorReciente.count++;
                    // Si ya se alcanz√≥ el m√°ximo de notificaciones, solo registrar
                    if (errorReciente.count > this._maxNotificacionesPorPeriodo) {
                        console.log(`‚ö†Ô∏è ErrorHandlingService: Error ya notificado ${errorReciente.count} veces, omitiendo notificaci√≥n`);
                        await this._registrarErrorSilencioso(error, contexto, errorReciente.count);
                        return;
                    }
                }
                else {
                    // Si pas√≥ el tiempo m√≠nimo, reiniciar contador
                    this._erroresCriticosRecientes.set(errorKey, { timestamp: ahora, count: 1 });
                }
            }
            else {
                // Si es un error nuevo, agregar al mapa
                this._erroresCriticosRecientes.set(errorKey, { timestamp: ahora, count: 1 });
            }
            // 2. Registrar error en base de datos
            await this._registrarErrorEnBaseDatos(error, contexto);
            // 3. Enviar notificaci√≥n a administradores
            await this._notificarAdministradores(error, contexto);
            // 4. Registrar en logs
            await this._registrarEnLogs(error, contexto);
            // 5. Limpiar errores antiguos del mapa
            this._limpiarErroresAntiguos();
            const duration = Date.now() - startTime;
            console.log(`‚úÖ ErrorHandlingService: Error cr√≠tico manejado en ${duration}ms`);
            logger_1.log.error('Error cr√≠tico manejado', {
                error: error.message,
                componente: contexto.componente,
                accion: contexto.accion,
                duration: `${duration}ms`,
                timestamp: ahora.toISOString(),
            });
        }
        catch (manejoError) {
            const duration = Date.now() - startTime;
            console.error(`‚ùå ErrorHandlingService: Error manejando error cr√≠tico:`, manejoError);
            // NUEVO: No fallar completamente, intentar registrar el error original
            try {
                await this._registrarErrorSilencioso(error, contexto, 0);
                await this._registrarErrorSilencioso(manejoError, {
                    componente: 'ErrorHandlingService',
                    accion: 'manejarErrorCritico',
                    errorOriginal: error.message,
                }, 0);
            }
            catch (registroError) {
                console.error(`‚ùå ErrorHandlingService: Error cr√≠tico no pudo ser registrado:`, registroError);
            }
            logger_1.log.error('Error manejando error cr√≠tico', {
                error: manejoError.message,
                errorOriginal: error.message,
                componente: contexto.componente,
                accion: contexto.accion,
                duration: `${duration}ms`,
                timestamp: new Date().toISOString(),
            });
        }
    }
    /**
     * NUEVO: Registrar error en base de datos
     */
    async _registrarErrorEnBaseDatos(error, contexto) {
        try {
            await prisma.log.create({
                data: {
                    tipo: 'error_critico',
                    mensaje: error.message,
                    datos: {
                        componente: contexto.componente,
                        accion: contexto.accion,
                        datos: contexto.datos,
                        stack: error.stack,
                        usuarioId: contexto.usuarioId,
                        gestanteId: contexto.gestanteId,
                        timestamp: new Date().toISOString(),
                    },
                    nivel: 'critico',
                    usuario_id: contexto.usuarioId,
                    fecha_creacion: new Date(),
                },
            });
        }
        catch (dbError) {
            console.error(`‚ùå ErrorHandlingService: Error registrando en base de datos:`, dbError);
            throw dbError;
        }
    }
    /**
     * NUEVO: Notificar a administradores sobre el error cr√≠tico
     */
    async _notificarAdministradores(error, contexto) {
        try {
            // Obtener administradores y coordinadores
            const administradores = await prisma.usuario.findMany({
                where: {
                    rol: { in: ['admin', 'super_admin'] },
                    activo: true,
                },
            });
            // Preparar mensaje de notificaci√≥n
            const mensaje = `‚ùå Error Cr√≠tico en ${contexto.componente}\n\n` +
                `Acci√≥n: ${contexto.accion}\n` +
                `Error: ${error.message}\n` +
                `Timestamp: ${new Date().toLocaleString('es-CO')}\n` +
                (contexto.usuarioId ? `Usuario ID: ${contexto.usuarioId}\n` : '') +
                (contexto.gestanteId ? `Gestante ID: ${contexto.gestanteId}\n` : '') +
                (contexto.datos ? `Datos: ${JSON.stringify(contexto.datos, null, 2)}` : '');
            // Enviar notificaci√≥n a cada administrador
            for (const admin of administradores) {
                try {
                    await this.notificationService.enviarNotificacionAdmin({
                        tipo: 'error_critico',
                        titulo: `‚ùå Error Cr√≠tico en ${contexto.componente}`,
                        mensaje,
                        datos: {
                            componente: contexto.componente,
                            accion: contexto.accion,
                            error: error.message,
                            stack: error.stack,
                            datos: contexto.datos,
                            usuarioId: contexto.usuarioId,
                            gestanteId: contexto.gestanteId,
                            timestamp: new Date().toISOString(),
                        },
                        prioridad: 'critica',
                    });
                }
                catch (notifError) {
                    console.error(`‚ùå ErrorHandlingService: Error notificando a admin ${admin.id}:`, notifError);
                }
            }
        }
        catch (notifError) {
            console.error(`‚ùå ErrorHandlingService: Error en notificaci√≥n a administradores:`, notifError);
            throw notifError;
        }
    }
    /**
     * NUEVO: Registrar en logs
     */
    async _registrarEnLogs(error, contexto) {
        try {
            await this.logService.registrarEvento({
                tipo: 'error_critico',
                datos: {
                    componente: contexto.componente,
                    accion: contexto.accion,
                    error: error.message,
                    stack: error.stack,
                    datos: contexto.datos,
                    usuarioId: contexto.usuarioId,
                    gestanteId: contexto.gestanteId,
                    timestamp: new Date().toISOString(),
                },
                nivel: 'critico',
            });
        }
        catch (logError) {
            console.error(`‚ùå ErrorHandlingService: Error registrando en logs:`, logError);
            throw logError;
        }
    }
    /**
     * NUEVO: Registrar error silenciosamente (sin notificaci√≥n)
     */
    async _registrarErrorSilencioso(error, contexto, conteo) {
        try {
            await prisma.log.create({
                data: {
                    tipo: 'error_critico_silenciado',
                    mensaje: error.message,
                    datos: {
                        componente: contexto.componente,
                        accion: contexto.accion,
                        datos: contexto.datos,
                        stack: error.stack,
                        usuarioId: contexto.usuarioId,
                        gestanteId: contexto.gestanteId,
                        conteo,
                        timestamp: new Date().toISOString(),
                    },
                    nivel: 'alto',
                    usuario_id: contexto.usuarioId,
                    fecha_creacion: new Date(),
                },
            });
        }
        catch (error) {
            console.error(`‚ùå ErrorHandlingService: Error registrando error silenciosamente:`, error);
        }
    }
    /**
     * NUEVO: Limpiar errores antiguos del mapa
     */
    _limpiarErroresAntiguos() {
        const ahora = new Date();
        const erroresAEliminar = [];
        for (const [key, error] of this._erroresCriticosRecientes.entries()) {
            const tiempoTranscurrido = ahora.getTime() - error.timestamp.getTime();
            // Eliminar errores que tienen m√°s del doble del tiempo m√≠nimo
            if (tiempoTranscurrido > this._tiempoMinimoNotificacion * 2) {
                erroresAEliminar.push(key);
            }
        }
        for (const key of erroresAEliminar) {
            this._erroresCriticosRecientes.delete(key);
        }
        if (erroresAEliminar.length > 0) {
            console.log(`üßπ ErrorHandlingService: Limpiados ${erroresAEliminar.length} errores antiguos`);
        }
    }
    /**
     * NUEVO: Obtener estad√≠sticas de errores cr√≠ticos
     */
    obtenerEstadisticasErroresCriticos() {
        const ahora = new Date();
        const recientes = Array.from(this._erroresCriticosRecientes.values()).filter(error => ahora.getTime() - error.timestamp.getTime() < this._tiempoMinimoNotificacion).length;
        const masFrecuentes = Array.from(this._erroresCriticosRecientes.entries())
            .map(([key, error]) => ({ key, count: error.count, ultimo: error.timestamp }))
            .sort((a, b) => b.count - a.count)
            .slice(0, 5);
        return {
            total: this._erroresCriticosRecientes.size,
            recientes,
            masFrecuentes,
        };
    }
    /**
     * NUEVO: Limpiar mapa de errores cr√≠ticos
     */
    limpiarErroresCriticos() {
        const cantidad = this._erroresCriticosRecientes.size;
        this._erroresCriticosRecientes.clear();
        console.log(`üßπ ErrorHandlingService: Limpiados ${cantidad} errores cr√≠ticos del mapa`);
    }
    /**
     * NUEVO: Manejar advertencias con notificaci√≥n opcional
     */
    async manejarAdvertencia(advertencia, contexto, notificar = false) {
        try {
            console.warn(`‚ö†Ô∏è ErrorHandlingService: Advertencia en ${contexto.componente}.${contexto.accion}:`, advertencia);
            // Registrar advertencia en base de datos
            await prisma.log.create({
                data: {
                    tipo: 'advertencia',
                    mensaje: advertencia,
                    datos: {
                        componente: contexto.componente,
                        accion: contexto.accion,
                        datos: contexto.datos,
                        usuarioId: contexto.usuarioId,
                        gestanteId: contexto.gestanteId,
                        timestamp: new Date().toISOString(),
                    },
                    nivel: 'medio',
                    usuario_id: contexto.usuarioId,
                    fecha_creacion: new Date(),
                },
            });
            // Si se solicita notificar, enviar a administradores
            if (notificar) {
                const administradores = await prisma.usuario.findMany({
                    where: {
                        rol: { in: ['admin', 'super_admin'] },
                        activo: true,
                    },
                });
                const mensaje = `‚ö†Ô∏è Advertencia en ${contexto.componente}\n\n` +
                    `Acci√≥n: ${contexto.accion}\n` +
                    `Mensaje: ${advertencia}\n` +
                    `Timestamp: ${new Date().toLocaleString('es-CO')}`;
                for (const admin of administradores) {
                    try {
                        await this.notificationService.enviarNotificacionAdmin({
                            tipo: 'advertencia',
                            titulo: `‚ö†Ô∏è Advertencia en ${contexto.componente}`,
                            mensaje,
                            datos: {
                                componente: contexto.componente,
                                accion: contexto.accion,
                                advertencia,
                                datos: contexto.datos,
                                usuarioId: contexto.usuarioId,
                                gestanteId: contexto.gestanteId,
                                timestamp: new Date().toISOString(),
                            },
                            prioridad: 'media',
                        });
                    }
                    catch (notifError) {
                        console.error(`‚ùå ErrorHandlingService: Error notificando advertencia a admin ${admin.id}:`, notifError);
                    }
                }
            }
            logger_1.log.warn('Advertencia manejada', {
                advertencia,
                componente: contexto.componente,
                accion: contexto.accion,
                notificar,
                timestamp: new Date().toISOString(),
            });
        }
        catch (error) {
            console.error(`‚ùå ErrorHandlingService: Error manejando advertencia:`, error);
            logger_1.log.error('Error manejando advertencia', {
                error: error.message,
                advertencia,
                componente: contexto.componento,
                accion: contexto.accion,
                timestamp: new Date().toISOString(),
            });
        }
    }
}
exports.ErrorHandlingService = ErrorHandlingService;
// Singleton del servicio
exports.errorHandlingService = new ErrorHandlingService();
